# InfoWorks ICM Ruby Tutorial Context for AI/LLM Code Generation

Original generated by AI **Last Updated:** October 15, 2025

## **About This Document**

This is a **tutorial-style context guide** for learning InfoWorks ICM Ruby scripting. 

**Companion Guides:**
- **Database Reference** (`InfoWorks_ICM_Ruby_Database_Reference.md`) - Database table name lookup
- **Pattern Reference** (`InfoWorks_ICM_Ruby_Pattern_Reference.md`) - Pattern catalog with IDs

This context file is being **organically evolved and trialed** to improve the effectiveness of AI models (LLMs) in generating InfoWorks ICM-specific Ruby scripts. The patterns, examples, and guidance contained herein have been extracted from real-world scripts in the Open-Source-Support repository and validated against actual InfoWorks ICM implementations.

### **Purpose & Evolution**
- **Primary Goal**: Enable AI models to generate accurate, idiomatic InfoWorks ICM Ruby code through comprehensive examples
- **Development Approach**: Iterative enhancement based on practical examples and user feedback
- **Validation Method**: All patterns tested against actual repository examples with source references
- **Scope**: Covers both UI and Exchange scripting environments with cross-product pattern analysis
- **Best For**: Learning, understanding concepts, generating complete scripts from scratch

### **When to Use Which Guide**
- **Use Tutorial Context (this file)**: Learning Ruby scripting, understanding concepts, generating complete scripts
- **Use Pattern Reference**: Quick pattern lookup, specific pattern IDs, composing complex scripts from patterns
- **Use Database Reference**: Looking up database table names (`hw_*`, `sw_*`) for row_objects() calls

### **Contributing Updates**
If you have suggestions for improvements or additional patterns, please provide:
1. **Specific code examples** with working implementations
2. **Justification** for why the pattern enhances AI code generation
3. **Validation** that the pattern works in InfoWorks ICM environments

## See Also
- **Database Reference**: `InfoWorks_ICM_Ruby_Database_Reference.md` - Complete table name lookup for row_objects() calls
- **Pattern Reference**: `InfoWorks_ICM_Ruby_Pattern_Reference.md` - Concise pattern catalog with IDs and metadata

---

## Overview
InfoWorks ICM provides two main Ruby scripting environments:
1. **UI Scripts**: Run within the InfoWorks ICM graphical interface (`WSApplication.current_network`)
2. **Exchange Scripts**: Run independently via Exchange API (`WSApplication.open`)

## Quick Reference for AI Code Generation

### When to Use UI vs Exchange Scripts
- **UI Scripts**: Interactive network analysis, real-time data modification, working with current selection
- **Exchange Scripts**: Automated processing, simulation management, batch operations, database operations

### Key Decision Points for Script Generation
1. **Data Modification**: Always use transactions (`net.transaction_begin` / `net.transaction_commit`)
2. **Object Selection**: Check if objects are selected first, fall back to all objects if none selected
3. **Network Tracing**: Use `_seen` flags to prevent infinite loops, clean up afterwards
4. **Error Handling**: Wrap operations in begin/rescue blocks
5. **Results Access**: Use background network (`WSApplication.background_network`) for simulation results

### Most Common Script Patterns
1. **Bulk Property Updates**: Modify multiple objects with transaction handling
2. **Network Tracing**: Trace upstream/downstream connections from selected objects
3. **Relationship Analysis**: Find connections between subcatchments, land uses, and runoff surfaces
4. **Data Export**: Export object properties and results to CSV files
5. **Selection Management**: Create selections based on criteria or relationships

## Core Architecture

### Application Access
```ruby
# UI Scripts - Access current open network
net = WSApplication.current_network

# Exchange Scripts - Open database programmatically
db_file = "path\\to\\database.icmm"
db = WSApplication.open(db_file, false)  # false = read/write, true = read-only
```

### Universal UI/Exchange Pattern
```ruby
# Pattern for scripts that work in both UI and Exchange modes
if WSApplication.ui?
    # UI Mode - use current network
    net = WSApplication.current_network
else
    # Exchange Mode - open database and network
    db = WSApplication.open('database_path.icmm', false)
    mo = db.model_object_from_type_and_id('Model Network', network_id)
    net = mo.open
end
```

### Network and Model Objects
```ruby
# Get model object from network (UI)
mo = net.model_object

# Access model groups and networks
group = db.model_object('>MODG~Model group')
network = db.model_object('>MODG~Model group>NNET~Model network')
```

## Data Access Patterns

### Row Objects (Single Objects)
```ruby
# Get single object by ID
node = net.row_object('hw_node', 'NODE_ID')
subcatchment = net.row_object('hw_subcatchment', 'SUBCAT_ID')

# Check if object exists
if node.nil?
  puts "Node not found"
  return
end
```

### Row Object Collections (Multiple Objects)
```ruby
# Get all objects of a table
nodes = net.row_objects('hw_node')
conduits = net.row_objects('hw_conduit')
subcatchments = net.row_objects('hw_subcatchment')

# Iterate through collections using different methods
net.row_objects('hw_node').each do |node|
  puts node.id
  puts node.x, node.y  # coordinates
end

# Alternative iteration using row_object_collection
net.row_object_collection('hw_node').each do |node|
  puts node.node_id  # note: some tables use different ID field names
end

# Get selected objects only
selected_nodes = net.row_object_collection_selection('_nodes')
selected_runoff = net.row_objects_selection('hw_runoff_surface')
```

### Database Table Names

**NOTE:** For complete database table name listings, see `InfoWorks_ICM_Ruby_Database_Reference.md`.

**Commonly Used InfoWorks Tables:**
- `hw_node` - Manholes/nodes
- `hw_conduit` - Pipes/conduits  
- `hw_subcatchment` - Subcatchments
- `hw_river_reach` - River reaches
- `hw_runoff_surface` - Runoff surfaces
- `hw_land_use` - Land use definitions

**SWMM Tables:** Use `sw_` prefix instead of `hw_` (e.g., `sw_node`, `sw_conduit`, `sw_subcatchment`)

**Critical:** Always use database table names (e.g., `'hw_conduit'`) NOT UI names (e.g., `'Conduit'`) in `row_objects()` calls.

### Special Collection Names
- `_nodes` - All node-type objects (for selection)
- `_links` - All link-type objects (for selection)
- `_subcatchments` - All subcatchment objects (for selection)

## Data Modification Patterns

### Transaction Management
```ruby
# Always wrap modifications in transactions
net.transaction_begin
begin
  # Modify objects here
  node.ground_level = 100.0
  node.write  # Commit changes to object
rescue => e
  puts "Error: #{e}"
ensure
  net.transaction_commit
end

# Commit changes to database
net.commit("Description of changes made")
```

### Object Property Access and Modification
```ruby
# Read properties - different objects have different ID field names
puts node.node_id        # for hw_node
puts node.id            # generic ID (may be different from display ID)
puts conduit.us_node_id  # upstream node ID for conduits
puts subcatchment.land_use_id  # land use reference

# Coordinate access
puts node.x, node.y
puts subcatchment.x, subcatchment.y  # subcatchment centroid

# Modify properties
node.ground_level = 100.0
node.flood_level = 105.0
node.user_text_1 = "Custom data"
subcatchment.drying_time = 1

# Dynamic field access using bracket notation
runoff_surface = land_use["runoff_index_1"]  # First runoff surface
land_use["runoff_index_2"] = "GRASS"        # Set second runoff surface

# Must call write() after modifications
node.write
```

### Complex Object Data (Sections, Cross-sections, WSStructures)
```ruby
# River reach sections
net.row_objects('hw_river_reach').each do |reach|
  reach.sections.each do |section|
    section.roughness_N = section.roughness_N * 0.8  # Modify roughness
  end
  reach.sections.write  # Write sections
  reach.write          # Write parent object
end

# WSStructure handling (for complex arrays like RTC, cross-sections)
def update_structure_from_array(structure, data_array)
  # Validation
  raise "Structure is not a WSStructure" unless structure.is_a?(WSStructure)
  raise "Data is not an Array" unless data_array.is_a?(Array)
  
  # Resize structure to match data
  structure.length = data_array.length
  
  # Update each row
  data_array.each_with_index do |data_hash, i|
    struct_row = structure[i]
    data_hash.each { |key, value| struct_row[key] = value }
  end
  
  # Write changes
  structure.write
end
```

## Selection and Navigation

### Selection Management
```ruby
# Clear all selections
net.clear_selection

# Select objects programmatically
node.selected = true
conduit.selected = true

# Check if object is selected
if node.selected?
  puts "Node is selected"
end
```

### Network Navigation
```ruby
# Navigate node relationships
node.us_links.each do |upstream_link|
  puts upstream_link.id
end

node.ds_links.each do |downstream_link|
  puts downstream_link.id
end

# Navigate link relationships
link.us_node  # upstream node
link.ds_node  # downstream node

# Navigate subcatchment connections
subcatchment.node_id  # connected node
node.navigate('subcatchments')  # get connected subcatchments
```

### Network Tracing
```ruby
# Basic tracing initialization
unprocessed_links = Array.new
seen_objects = Array.new

# Mark objects as seen to prevent infinite loops
def mark_seen(object)
  object._seen = true
  seen_objects << object
end

# Simple downstream tracing
node.ds_links.each do |link|
  if !link._seen
    unprocessed_links << link
    mark_seen(link)
  end
end

while unprocessed_links.size > 0
  working_link = unprocessed_links.shift
  working_link.selected = true
  
  ds_node = working_link.ds_node
  if ds_node && !ds_node._seen
    ds_node.selected = true
    mark_seen(ds_node)
    # Continue tracing downstream
    ds_node.ds_links.each do |next_link|
      if !next_link._seen
        unprocessed_links << next_link
        mark_seen(next_link)
      end
    end
  end
end

# Advanced tracing with conditional exclusion
def trace_network_with_conditions(start_node, upstream = true, conditions = {})
  start_node.selected = true
  unprocessed_links = []
  
  # Get initial links based on direction
  initial_links = upstream ? start_node.us_links : start_node.ds_links
  
  # Apply initial conditions
  initial_links.each do |link|
    next if link._seen
    
    # Check exclusion conditions
    exclude = false
    conditions.each do |field, condition|
      case condition[:operator]
      when '>'
        exclude = true if link[field] && link[field] > condition[:value]
      when '<'
        exclude = true if link[field] && link[field] < condition[:value]
      when '=='
        exclude = true if link[field] == condition[:value]
      when 'nil'
        exclude = true if link[field].nil?
      end
    end
    
    unless exclude
      unprocessed_links << link
      link._seen = true
    end
  end
  
  # Process queue
  iterations = 0
  max_iterations = 10000  # Prevent infinite loops
  
  while unprocessed_links.size > 0 && iterations < max_iterations
    working_link = unprocessed_links.shift
    working_link.selected = true
    
    # Get next node based on direction
    next_node = upstream ? working_link.us_node : working_link.ds_node
    
    if next_node && !next_node._seen
      next_node.selected = true
      next_node._seen = true
      
      # Get next links
      next_links = upstream ? next_node.us_links : next_node.ds_links
      
      next_links.each do |next_link|
        next if next_link._seen
        
        # Apply conditions to next links
        exclude = false
        conditions.each do |field, condition|
          case condition[:operator]
          when '>'
            exclude = true if next_link[field] && next_link[field] > condition[:value]
          when '<'
            exclude = true if next_link[field] && next_link[field] < condition[:value]
          when '=='
            exclude = true if next_link[field] == condition[:value]
          when 'nil'
            exclude = true if next_link[field].nil?
          end
        end
        
        unless exclude
          unprocessed_links << next_link
          next_link._seen = true
        end
      end
    end
    
    iterations += 1
  end
  
  puts "Trace completed in #{iterations} iterations"
end

# Usage example: Trace upstream excluding high invert levels
# trace_network_with_conditions(start_node, true, {
#   'us_invert' => { operator: '>', value: 15.0 }
# })
```

## Results Handling

### Background Network Access
```ruby
# Access simulation results through background network
bn = WSApplication.background_network
net = WSApplication.current_network  # Current network for structure
```

### Timesteps and Results
```ruby
# Get simulation timesteps
timesteps = net.list_timesteps
timestep_count = net.timestep_count

# Get results from objects
results_points = net.row_objects('hw_1d_results_point')
results_points.each do |point|
  results = point.results('qfull')  # Get specific result type
  puts point.id, results.max       # Maximum value
  puts results.min, results.mean   # Other statistics
end

# Export results to arrays for further processing
results_array = Array.new
results_points.each do |point|
  results_array << point.results('qfull')
end
```

### Results Field Discovery
```ruby
require 'set'

# Discover available results fields
results_set = Set.new
net.row_object_collection('hw_1d_results_point').each do |point|
  next unless point.table_info.results_fields
  
  point.table_info.fields.each do |field|
    results_set << field.name
  end
end

puts "Available results fields: #{results_set.to_a}"
```

### Common Result Field Names
- Flow: `qfull`, `qpipe`, `qlink`, `mcpl1dis`
- Depth: `dpfull`, `dp`, `mcpl1dep`
- Velocity: `vfull`, `vpipe`, `mcpl1vel`
- Volume: `volfull`
- Flooding: `qflood`, `vflood`

## Simulation Management (Exchange Scripts Only)

### Running Simulations
```ruby
# Create simulation run
group = db.model_object('>MODG~Model group')
run_params = Hash.new
run_params['Duration'] = 24*60  # minutes
run_params['DurationUnit'] = 'Minutes'
run_params['TimeStep'] = 1
run_params['Level'] = '>MODG~Model group>LEV~Level'

run = group.new_run(
  "Run Name",
  'MODG~Model Group>NNET~Model network',
  nil,  # commit ID
  1,    # rainfall event ID
  nil,
  run_params
)

# Launch simulation
sim = run.children[0]
WSApplication.connect_local_agent(1)
handles = WSApplication.launch_sims([sim], '.', false, 0, 0)

# Wait for completion
while sim.status == 'None'
  sleep 1
end
```

## Data Import/Export

### ODEC Export
```ruby
# Basic ODEC export
options = Hash.new
options['Error File'] = './export_errors.txt'

net.odec_export_ex(
  'CSV',                    # format
  './config.cfg',          # config file
  options,                 # options hash
  'Node',                  # table name
  'exported_nodes.csv'     # output file
)

# Advanced ODEC Configuration Pattern
def configure_odec_export(format, config_file, export_options = {})
  # Standard configuration
  options = {
    'Error File' => './export_errors.txt',
    'Coordinate System' => 'Grid',
    'Use Display Precision' => true,
    'Export Only Selected' => false,
    'Include Images' => false,
    'Include Videos' => false
  }.merge(export_options)
  
  # Additional format-specific options
  case format.upcase
  when 'CSV'
    options['Delimiter'] = ','
    options['Units Row'] = true
    options['Title Row'] = true
  when 'MIF'
    options['Coordinate System'] = 'Grid'
    options['Export WKT'] = true
  when 'SHP'
    options['Include NULL Fields'] = false
  end
  
  options
end

# Multi-table export with error handling
def export_multiple_tables(net, tables, format = 'CSV')
  export_dir = './exports'
  Dir.mkdir(export_dir) unless Dir.exist?(export_dir)
  
  results = {}
  
  tables.each do |table_name|
    begin
      output_file = File.join(export_dir, "#{table_name}.#{format.downcase}")
      config_file = File.join(export_dir, "#{table_name}_config.cfg")
      
      options = configure_odec_export(format, config_file, {
        'Export Only Selected' => false
      })
      
      net.odec_export_ex(format, config_file, options, table_name, output_file)
      results[table_name] = { success: true, file: output_file }
      
    rescue => e
      results[table_name] = { success: false, error: e.message }
    end
  end
  
  results
end
```

### File Operations
```ruby
require 'csv'
require 'date'

# Set working directory
Dir.chdir('C:/Temp')

# CSV export example
CSV.open('results.csv', 'w') do |csv|
  csv << ['Node ID', 'X', 'Y', 'Ground Level']
  net.row_objects('hw_node').each do |node|
    csv << [node.node_id, node.x, node.y, node.ground_level]
  end
end
```

## Utility Functions and Patterns

### Hash-based Object Tracking
```ruby
# Common pattern for tracking objects using hashes
selected_objects = Hash.new
processed_objects = Hash.new

# Add objects to hash for fast lookup
net.row_objects_selection('hw_runoff_surface').each do |obj|
  selected_objects[obj.id.to_s] = 0  # or any value
end

# Check if object is in hash
if selected_objects.has_key?(object_id.to_s)
  # Process object
end
```

### Dynamic Field Access
```ruby
# Access fields dynamically using bracket notation
(1..10).each do |i|
  runoff_surface = land_use["runoff_index_#{i}"]
  if !runoff_surface.nil?
    puts "Found runoff surface: #{runoff_surface}"
  end
end
```

### Error Handling
```ruby
begin
  # Main script logic
  net.transaction_begin
  # modifications
  net.transaction_commit
rescue => e
  puts "Error occurred: #{e.message}"
  puts e.backtrace.join("\n") if e.backtrace
ensure
  # cleanup code
end
```

### Distance Calculations
```ruby
# Calculate distance between points
def distance(x1, y1, x2, y2)
  Math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
end

# Find nearest node to subcatchment
min_distance = Float::INFINITY
nearest_node = nil

nodes.each do |node|
  dist = distance(subcatchment.x, subcatchment.y, node.x, node.y)
  if dist < min_distance
    min_distance = dist
    nearest_node = node
  end
end
```

### GUID Generation
```ruby
require 'Win32API'

# Create unique identifiers
uuid_create = Win32API.new('rpcrt4', 'UuidCreate', 'P', 'L')
def new_guid
  result = ' ' * 16
  uuid_create.call(result)
  a, b, c, d, e, f, g, h = result.unpack('SSSSSSSS')
  sprintf('%04X%04X-%04X-%04X-%04X-%04X%04X%04X', a, b, c, d, e, f, g, h)
end
```

### Table and Field Discovery
```ruby
# List all tables in network
net.tables.each do |table|
  puts "Table: #{table.name}"
  
  # List fields in table
  table.fields.each do |field|
    puts "  Field: #{field.name} (#{field.data_type})"
  end
end
```

### Array and Data Structure Processing
```ruby
# Safe array operations with nil handling
def safe_array_operation(array, &block)
  return [] if array.nil? || array.empty?
  
  array.compact.map do |item|
    begin
      yield(item)
    rescue => e
      puts "Warning: Error processing item #{item}: #{e.message}"
      nil
    end
  end.compact
end

# Convert WSStructure to Array for processing
def structure_to_array(structure)
  return [] unless structure.is_a?(WSStructure)
  
  result = []
  (0...structure.length).each do |i|
    row_data = {}
    structure[i].table_info.fields.each do |field|
      row_data[field.name] = structure[i][field.name]
    end
    result << row_data
  end
  result
end

# Batch processing with progress tracking
def batch_process_objects(objects, batch_size = 100)
  total = objects.length
  processed = 0
  
  objects.each_slice(batch_size) do |batch|
    batch.each do |obj|
      yield(obj) if block_given?
      processed += 1
    end
    
    puts "Progress: #{processed}/#{total} (#{(processed.to_f/total*100).round(1)}%)"
  end
end
```

### Spatial Operations
```ruby
# Calculate distance between two points
def calculate_distance(x1, y1, x2, y2)
  Math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
end

# Find objects within buffer distance
def find_objects_within_buffer(net, table_name, center_x, center_y, buffer_distance)
  nearby_objects = []
  
  net.row_objects(table_name).each do |obj|
    next unless obj.x && obj.y  # Skip objects without coordinates
    
    distance = calculate_distance(center_x, center_y, obj.x, obj.y)
    if distance <= buffer_distance
      nearby_objects << obj
    end
  end
  
  nearby_objects
end

# Spatial clustering of nodes
def cluster_nodes_by_proximity(net, cluster_distance = 10.0)
  clusters = []
  processed_nodes = Set.new
  
  net.row_objects('hw_node').each do |node|
    next if processed_nodes.include?(node.id)
    
    # Start new cluster
    cluster = [node]
    processed_nodes.add(node.id)
    
    # Find all nodes within cluster distance
    nearby_nodes = find_objects_within_buffer(net, 'hw_node', node.x, node.y, cluster_distance)
    nearby_nodes.each do |nearby_node|
      unless processed_nodes.include?(nearby_node.id)
        cluster << nearby_node
        processed_nodes.add(nearby_node.id)
      end
    end
    
    clusters << cluster if cluster.length > 1
  end
  
  clusters
end
```

## Scenario Management
```ruby
# Set current scenario
net.current_scenario = 'Base Scenario'
puts net.current_scenario

# Work with different scenarios
net.current_scenario = 'Modified Scenario'
# make changes
net.commit("Changes for modified scenario")
```

## Common Script Patterns and Templates

### Selection-Based Processing Template
```ruby
# Template for processing selected objects
net = WSApplication.current_network

# Get selected objects or use all if none selected
selected_objects = net.row_object_collection_selection('_nodes')
if selected_objects.length == 0
  puts "No objects selected, processing all objects"
  objects_to_process = net.row_objects('hw_node')
else
  puts "Processing #{selected_objects.length} selected objects"
  objects_to_process = selected_objects
end

# Process objects
objects_to_process.each do |obj|
  # Do something with obj
  puts obj.id
end
```

### Bulk Modification Template
```ruby
net = WSApplication.current_network
net.transaction_begin

modified_count = 0
net.row_objects('hw_node').each do |node|
  # Make modifications
  node.user_text_1 = "Modified"
  node.write
  modified_count += 1
end

net.transaction_commit
net.commit("Modified #{modified_count} nodes")
puts "Successfully modified #{modified_count} objects"
```

### Relationship Discovery Template
```ruby
# Template for finding related objects
related_objects = Hash.new

# Build relationship map
primary_objects.each do |primary|
  related_objects[primary.id.to_s] = Array.new
  
  # Find related objects
  secondary_objects.each do |secondary|
    if secondary.primary_id == primary.id
      related_objects[primary.id.to_s] << secondary
    end
  end
end

# Use relationship map
related_objects.each do |primary_id, secondaries|
  puts "Primary #{primary_id} has #{secondaries.length} related objects"
end
```

## Common Script Categories

### Network Data Manipulation
- Modify object properties (roughness, levels, dimensions)
- Connect subcatchments to nearest nodes  
- Update inverts based on cross-sections
- Set flags and user text fields

### Network Analysis  
- Trace upstream/downstream networks
- Calculate cumulative areas
- Find connectivity issues
- Generate statistics

### Data Export/Import
- Export to CSV, MIF, geodatabase
- Import ground models
- Export results data
- Generate reports

### Simulation Management
- Create and run simulations
- Monitor simulation status
- Export binary results
- Handle multiple simulation runs

## Field Names and ID Conventions

### Object ID Fields
Different object types use different field names for their primary identifiers:
```ruby
# Node objects
node.node_id    # Display ID
node.id         # Internal ID

# Link objects  
conduit.us_node_id  # Upstream node ID
conduit.ds_node_id  # Downstream node ID
conduit.link_id     # Link display ID

# Subcatchment objects
subcatchment.id         # Internal ID
subcatchment.land_use_id # Land use reference

# Land use objects
land_use.land_use_id    # Display ID
```

### User-Defined Fields
```ruby
# User text fields (available on most objects)
object.user_text_1 = "Custom value 1"
object.user_text_2 = "Custom value 2"
# ... up to user_text_10

# User number fields
object.user_number_1 = 123.45
# ... up to user_number_10
```

## Best Practices

1. **Always use transactions** for data modifications
2. **Check for nil objects** before accessing properties
3. **Clear selections** at start of scripts if needed
4. **Use appropriate file paths** (absolute paths recommended)
5. **Include error handling** for robust scripts
6. **Mark objects as seen** during network tracing to prevent infinite loops
7. **Call write()** after modifying object properties
8. **Commit changes** with descriptive messages
9. **Use consistent ID field names** for each object type
10. **Convert IDs to strings** when using as hash keys

## Advanced Patterns

### Time-based Operations
```ruby
require 'date'

# Timestamp for unique identifiers
timestamp = Time.now.strftime('%Y%m%d_%H%M%S')
timestamp_readable = Time.now.strftime('%Y-%m-%d %H:%M:%S')

# Use in modifications
object.user_text_1 = "Modified_#{timestamp}"
```

### Conditional Object Processing
```ruby
# Process objects based on conditions
net.row_objects('hw_node').each do |node|
  # Skip if conditions not met
  next if node.ground_level.nil?
  next if node.system_type.downcase != 'storm'
  
  # Process node
  puts "Processing storm node: #{node.node_id}"
end
```

### Array and Collection Operations
```ruby
# Collect objects meeting criteria
selected_objects = Array.new
all_ids = Array.new

net.row_objects('hw_node').each do |node|
  all_ids << node.node_id
  selected_objects << node if node.selected?
end

# Use collected data
puts "Total nodes: #{all_ids.length}"
puts "Selected nodes: #{selected_objects.length}"
```

## Script Initialization Template
```ruby
#!/usr/bin/env ruby

# Standard requires for common operations
require 'csv'      # For CSV export
require 'date'     # For timestamps
require 'set'      # For unique collections

# InfoWorks ICM script initialization
begin
  # Get network (UI script)
  net = WSApplication.current_network
  
  # OR get database (Exchange script) 
  # db_file = "#{File.dirname(__FILE__)}\\database.icmm"
  # db = WSApplication.open(db_file, false)
  
  puts "Script started: #{Time.now}"
  puts "Network: #{net.model_object.name}"
  
  # Main script logic here
  
  puts "Script completed successfully: #{Time.now}"
  
rescue => e
  puts "Script error: #{e.message}"
  puts e.backtrace.join("\n") if e.backtrace
end
```

## Cross-Product Pattern Compatibility

### Universal Patterns (All Innovyze Products)
- **UI/Exchange Detection**: `WSApplication.ui?` pattern works across all products
- **Network Access**: `WSApplication.current_network` for UI, database access for Exchange
- **Basic Object Iteration**: `row_objects()`, `row_object_collection()` patterns
- **Selection Management**: `selected`, `clear_selection` methods
- **Transaction Management**: `transaction_begin`/`transaction_commit` pattern
- **Basic Navigation**: `us_links`, `ds_links`, `us_node`, `ds_node` relationships
- **Field Access**: Dynamic field access using `[]` notation and `respond_to?`

### InfoWorks ICM Specific Patterns
- **Results Access**: Results fields and timestep access (ICM only)
- **Simulation Management**: Exchange script simulation launching
- **2D Results**: 2D mesh and results handling
- **RTC**: Real-time control object access
- **SWMM Integration**: SWMM table access patterns

### Enhanced from Other Products
- **WSStructure Handling**: Array-to-structure patterns from WS Pro
- **Advanced ODEC**: Multi-table export configurations from InfoAsset
- **Conditional Tracing**: Exclusion-based network tracing from InfoAsset
- **Spatial Operations**: Distance calculations and clustering algorithms
- **Batch Processing**: Progress tracking and error handling from InfoAsset

## Common Pitfalls to Avoid

- Forgetting to call `write()` after property modifications (see Pattern Reference: PAT_BULK_MODIFY_012)
- Not using transactions for bulk operations (see Pattern Reference: PAT_TRANSACTION_004)
- Infinite loops in network tracing (use `_seen` flag - see Pattern Reference: PAT_TRACE_RESET_018)
- Assuming objects exist without nil checks (see Pattern Reference: PAT_NULL_GUARD_039)
- Not handling different system types (storm, foul, combined)
- File path issues (use forward slashes or double backslashes)
- Mixing up ID field names between different object types
- Not converting IDs to strings when using as hash keys
- Forgetting to clear `_seen` flags after network tracing (see Pattern Reference: PAT_TRACE_RESET_018)
- Not checking for empty or nil values in relationship fields
- Mixing product-specific patterns (e.g., JSON export not available in ICM)
- Not validating WSStructure types before array operations (see Pattern Reference: PAT_STRUCTURE_UPDATE_005)

---

## Summary & Next Steps

This tutorial context provides comprehensive examples and explanations for InfoWorks ICM Ruby scripting. For:
- **Quick pattern lookup**: See `InfoWorks_ICM_Ruby_Pattern_Reference.md`
- **Specific pattern composition**: Reference patterns by ID (e.g., PAT_TRACE_BASIC_006) in the Pattern Reference

**Pattern ID Cross-Reference Examples:**
- Network access: PAT_APP_ACCESS_001, PAT_UNIVERSAL_MODE_002
- Data modification: PAT_TRANSACTION_004, PAT_BULK_MODIFY_012
- Network tracing: PAT_TRACE_BASIC_006, PAT_TRACE_CONDITIONAL_007
- Error handling: PAT_ERROR_WRAP_028, PAT_NULL_GUARD_039
- Results: PAT_RESULTS_ACCESS_008
- Export: PAT_EXPORT_ODEC_010, PAT_FILE_WRITE_CSV