# InfoWorks ICM Ruby Pattern Reference for LLM Code Generation

Original generated by AI **Last Updated:** October 15, 2025

## Document Purpose
This is a **pattern reference guide** for LLM-assisted Ruby scripting in InfoWorks ICM. 

**Companion Guides:**
- **Database Reference** (`InfoWorks_ICM_Ruby_Database_Reference.md`) - Database table name lookup
- **Tutorial Context** (`InfoWorks_ICM_Ruby_Tutorial_Context.md`) - Complete examples and learning guide

## Pattern Index

**Patterns are organized in typical script execution order:**
1. **Initialization** (001-003): Environment setup and error handling
2. **Data Access** (004-006): Reading objects and schema discovery
3. **Selection & Filtering** (007-009): Working with object collections
4. **Modification** (010-013): Updating data safely
5. **Tracing & Navigation** (014-017): Network traversal
6. **Results** (018-020): Simulation output access
7. **Simulation** (021): Running simulations
8. **Import/Export** (022-024): Data exchange
9. **Spatial** (025-026): Geometry operations
10. **Utilities** (027-040): Helper patterns and performance

| Pattern ID | Category | Use When | Tags |
|------------|----------|----------|------|
| **Initialization Patterns** |
| PAT_APP_ACCESS_001 | Core | First line of any script | env, bootstrap |
| PAT_UNIVERSAL_MODE_002 | Core | Script runs in UI or Exchange | env, compat |
| PAT_SCRIPT_INIT_003 | Core | Robust script initialization | bootstrap, error-handling |
| **Data Access Patterns** |
| PAT_DATA_FETCH_004 | Data | Retrieve single or multiple objects | data, fetch |
| PAT_FIELD_DISCOVERY_005 | Data | Discover table schema | introspection, metadata |
| PAT_SCENARIO_SWITCH_006 | Data | Safely modify multiple scenarios | scenario, transaction |
| **Selection & Filtering Patterns** |
| PAT_SELECTION_FALLBACK_007 | Selection | Use selection or all objects | selection, fallback |
| PAT_SELECTION_CLEAR_008 | Selection | Clear before operation | selection, safety |
| PAT_SELECTION_MARKING_009 | Selection | Mark traversal output | selection, tracing |
| **Modification Patterns** |
| PAT_TRANSACTION_010 | Modification | Ensure atomic writes | safety, write, transaction |
| PAT_BULK_MODIFY_011 | Modification | Update many objects | bulk, write |
| PAT_STRUCTURE_UPDATE_012 | Modification | Update complex nested data | structure, bulk |
| PAT_IDEMPOTENT_FLAGGING_013 | Modification | Avoid double processing | safety, tracking |
| **Tracing & Navigation Patterns** |
| PAT_TRACE_BASIC_014 | Tracing | Downstream network traversal | network, tracing, selection |
| PAT_TRACE_CONDITIONAL_015 | Tracing | Filtered directional trace | network, filter, tracing |
| PAT_TRACE_RESET_016 | Tracing | Clear traversal flags | tracing, safety |
| PAT_RELATIONSHIP_MAP_017 | Tracing | Build relationship index | mapping, parent-child |
| **Results Patterns** |
| PAT_RESULTS_ACCESS_018 | Results | Extract simulation metrics | results, analysis |
| PAT_RESULTS_FIELDS_ENUM_019 | Results | Enumerate results fields | results, introspection |
| PAT_RESULTS_STAT_SUMMARY_020 | Results | Quick statistics | results, analysis |
| **Simulation Patterns** |
| PAT_SIM_RUN_021 | Simulation | Create and launch run (Exchange) | simulation, exchange |
| **Import/Export Patterns** |
| PAT_EXPORT_ODEC_022 | Import/Export | Export with format options | export, odec |
| PAT_FILE_WRITE_CSV_023 | Import/Export | Simple CSV export | export, csv |
| PAT_STRUCTURE_TO_ARRAY_024 | Import/Export | Export WSStructure | export, structure |
| **Spatial Patterns** |
| PAT_SPATIAL_CLUSTER_025 | Spatial | Group by distance | spatial, geometry |
| PAT_NEAREST_OBJECT_026 | Spatial | Find nearest node | spatial, proximity |
| **Utility Patterns** |
| PAT_ERROR_WRAP_027 | Utilities | Error boundary | error-handling, safety |
| PAT_NULL_GUARD_028 | Utilities | Early nil guard | safety, validation |
| PAT_SAFE_NUMERIC_029 | Utilities | Guard numeric operations | safety, validation |
| PAT_FIELD_EXISTS_030 | Utilities | Defensive field check | compat, validation |
| PAT_GUID_GEN_031 | Utilities | GUID generation | utility, tracking |
| PAT_DYNAMIC_FIELD_ACCESS_032 | Utilities | Bracket field access | utility, iteration |
| PAT_HASH_TRACKING_033 | Utilities | Fast object lookup | utility, performance |
| PAT_BATCH_PROCESS_034 | Utilities | Batch with progress | performance, logging |
| PAT_TIMESTAMP_035 | Utilities | Timestamp tokens | utility, audit |
| PAT_CONDITIONAL_FILTER_036 | Utilities | Early-out skip logic | performance, filtering |
| PAT_PROGRESS_LOG_037 | Utilities | Progress logger | performance, logging |
| PAT_FAST_LOOKUP_SET_038 | Utilities | Set for membership | performance, collection |
| PAT_ITERATION_CAP_039 | Utilities | Safety cap | safety, loops |
| PAT_COLLECTION_BUILD_040 | Utilities | Dual collection | utility, collection |
| PAT_COMMIT_MESSAGE_STD_041 | Utilities | Standardized commit | audit, governance |
| PAT_ENV_CONFIG_042 | Utilities | Environment-driven config | config, deployment |

---

## 1. Initialization Patterns

### PAT_APP_ACCESS_001: UI vs Exchange Access
**Intent:** Obtain network handle based on execution environment  
**Context:** First line of almost every script  
**Outputs:** `net` (network object)  
**Failure Modes:** Bad path, network not found, permission denied  

```ruby
# UI Script
net = WSApplication.current_network

# Exchange Script
db = WSApplication.open('path\\to\\database.icmm', false)
mo = db.model_object_from_type_and_id('Model Network', network_id)
net = mo.open
```

### PAT_UNIVERSAL_MODE_002: Dual-Mode Wrapper
**Intent:** Single entry pattern for UI and Exchange  
**Context:** Scripts deployed to both environments  
**Related:** PAT_APP_ACCESS_001, PAT_ENV_CONFIG_046  

```ruby
if WSApplication.ui?
  net = WSApplication.current_network
else
  db = WSApplication.open(ENV.fetch('ICM_DB_PATH','database.icmm'), false)
  mo = db.model_object_from_type_and_id('Model Network', ENV.fetch('ICM_NETWORK_ID','1'))
  net = mo.open
end
```

### PAT_SCRIPT_INIT_003: Robust Initialization
**Intent:** Standardized header with error trapping  
**Context:** Production scripts requiring reliability  

```ruby
require 'date'
require 'set'

begin
  net = WSApplication.current_network if WSApplication.ui?
  puts "Script start: #{Time.now}" if net
rescue => e
  STDERR.puts "Initialization error: #{e.message}"
  exit 1
end
```

---

## 2. Data Access Patterns

### PAT_DATA_FETCH_004: Row Object Fetch
**Intent:** Safe object retrieval  
**Outputs:** Single object or collection  
**Failure Modes:** Returns nil if not found  

```ruby
# Single object
node = net.row_object('hw_node', 'NODE_ID')
raise 'Node not found' unless node

# Collection
nodes = net.row_objects('hw_node')
nodes.each { |n| puts n.id }
```

### PAT_FIELD_DISCOVERY_005: Schema Introspection
**Intent:** Adapt to schema variations  
**Context:** Cross-version scripts  

```ruby
net.tables.each do |table|
  puts "Table: #{table.name}"
  table.fields.each { |f| puts "  #{f.name} (#{f.data_type})" }
end
```

---

## 3. Selection & Collection Patterns

### PAT_SELECTION_FALLBACK_007: Selection or All
**Intent:** Use selection if exists, else all objects  

```ruby
sel = net.row_object_collection_selection('_nodes')
objects = sel.length > 0 ? sel : net.row_objects('hw_node')
```

### PAT_SELECTION_CLEAR_008: Clear Before Operation
**Intent:** Ensure clean selection state  

```ruby
net.clear_selection
```

### PAT_SELECTION_MARKING_009: Mark Traversal Output
**Intent:** Use selection as trace output channel  

```ruby
def mark_selected(obj)
  obj.selected = true if obj && obj.respond_to?(:selected=)
end
```

---

## 4. Modification Patterns

### PAT_TRANSACTION_010: Transaction Wrapper
**Intent:** Ensure atomicity of batch writes  
**Context:** All multi-object modifications  
**Failure Modes:** Rollback on exception  

```ruby
net.transaction_begin
begin
  net.row_objects('hw_node').each do |n|
    n.user_text_1 = 'Modified'
    n.write
  end
  net.transaction_commit
rescue => e
  STDERR.puts "Transaction failed: #{e.message}"
end
net.commit('Updated nodes')
```

### PAT_BULK_MODIFY_011: Bulk Update Template
**Intent:** Scalable property updates  
**Outputs:** Count of modified objects  

```ruby
net.transaction_begin
modified = 0
net.row_objects('hw_node').each do |n|
  next unless n.ground_level
  n.user_number_1 = n.ground_level * 1.1
  n.write
  modified += 1
end
net.transaction_commit
net.commit("Modified #{modified} nodes")
```

### PAT_STRUCTURE_UPDATE_012: WSStructure from Array
**Intent:** Transform array of hashes to WSStructure  
**Context:** Complex nested data (RTC, cross-sections)  

```ruby
def update_structure_from_array(structure, rows)
  raise 'Not WSStructure' unless structure.is_a?(WSStructure)
  structure.length = rows.length
  rows.each_with_index do |data, i|
    data.each { |key, val| structure[i][key] = val }
  end
  structure.write
end
```

### PAT_IDEMPOTENT_FLAGGING_013: Avoid Double Processing
**Intent:** Track processed objects  

```ruby
processed = {}
net.row_objects('hw_conduit').each do |c|
  next if processed[c.id]
  # work
  processed[c.id] = true
end
```

---

## 5. Tracing & Navigation Patterns

### PAT_TRACE_BASIC_014: Downstream Trace
**Intent:** Traverse downstream links  
**Side Effects:** Sets `selected=true`, marks `_seen`  

```ruby
def trace_downstream(start_node)
  queue = [start_node]
  start_node._seen = true
  
  while queue.any?
    node = queue.shift
    node.selected = true
    
    node.ds_links.each do |link|
      next if link._seen
      link._seen = true
      link.selected = true
      
      ds_node = link.ds_node
      if ds_node && !ds_node._seen
        ds_node._seen = true
        queue << ds_node
      end
    end
  end
end
```

### PAT_TRACE_CONDITIONAL_015: Filtered Trace
**Intent:** Conditional directional traversal  
**Inputs:** `conditions` hash with field/operator/value  

```ruby
def trace_with_conditions(start_node, upstream: true, conditions: {})
  queue = [start_node]
  start_node._seen = true
  
  while queue.any?
    node = queue.shift
    node.selected = true
    links = upstream ? node.us_links : node.ds_links
    
    links.each do |link|
      next if link._seen || exclude_link?(link, conditions)
      link._seen = true
      link.selected = true
      next_node = upstream ? link.us_node : link.ds_node
      queue << next_node if next_node && !next_node._seen
      next_node._seen = true if next_node
    end
  end
end

def exclude_link?(link, conditions)
  conditions.any? do |field, spec|
    val = link[field]
    case spec[:operator]
    when '>' then val && val > spec[:value]
    when '<' then val && val < spec[:value]
    when '==' then val == spec[:value]
    when 'nil' then val.nil?
    else false
    end
  end
end
```

### PAT_TRACE_RESET_016: Reset Traversal Flags
**Intent:** Clear `_seen` flags after tracing  
**Context:** After any trace operation  

```ruby
def reset_seen(net)
  %w[hw_node hw_conduit].each do |tbl|
    net.row_objects(tbl).each { |o| o._seen = false if o.respond_to?(:_seen=) }
  end
end
```

---

## 6. Results Handling Patterns

### PAT_RESULTS_ACCESS_018: Access 1D Results
**Intent:** Extract simulation metrics  
**Context:** After simulation run  

```ruby
points = net.row_objects('hw_1d_results_point')
qfull_max = points.map { |p| p.results('qfull').max }
puts "Max qfull: #{qfull_max.max}"
```

### PAT_RESULTS_FIELDS_ENUM_019: Enumerate Results Fields
**Intent:** Discover available result fields  

```ruby
fields = points.first.table_info.fields.map(&:name)
puts fields.join(',')
```

### PAT_RESULTS_STAT_SUMMARY_020: Quick Statistics
**Intent:** Min/max/mean for result field  

```ruby
def summarize_results(ro, field)
  r = ro.results(field)
  { min: r.min, max: r.max, mean: r.mean }
end
```

---

## 7. Simulation Management (Exchange Only)

### PAT_SIM_RUN_021: Create and Launch Simulation
**Intent:** Programmatic simulation execution  
**Context:** Exchange scripts only  

```ruby
run = group.new_run('Run Name', 'MODG~Group>NNET~Network', nil, 1, nil, 
  {'Duration'=>1440, 'DurationUnit'=>'Minutes', 'TimeStep'=>1})
sim = run.children[0]
WSApplication.connect_local_agent(1)
WSApplication.launch_sims([sim], '.', false, 0, 0)
```

---

## 8. Import/Export Patterns

### PAT_EXPORT_ODEC_022: Configurable ODEC Export
**Intent:** Export with format-specific options  

```ruby
def configure_odec(format, overrides={})
  base = {'Error File'=>'./errors.txt', 'Coordinate System'=>'Grid', 'Use Display Precision'=>true}
  base.merge(overrides)
end

opts = configure_odec('CSV', {'Delimiter'=>','})
net.odec_export_ex('CSV', './cfg.cfg', opts, 'Node', 'nodes.csv')
```

### PAT_FILE_WRITE_CSV_023: Simple CSV Export
**Intent:** Export rows to CSV  

```ruby
require 'csv'
CSV.open(path, 'w') do |csv|
  csv << ['ID', 'X', 'Y', 'Level']
  net.row_objects('hw_node').each do |n|
    csv << [n.node_id, n.x, n.y, n.ground_level]
  end
end
```

---

## 9. Spatial & Geometry Patterns

### PAT_SPATIAL_CLUSTER_025: Spatial Clustering
**Intent:** Group nodes by distance threshold  

```ruby
def cluster_nodes(net, threshold=10.0)
  require 'set'
  clusters = []
  processed = Set.new
  
  net.row_objects('hw_node').each do |node|
    next if processed.include?(node.id)
    cluster = [node]
    processed.add(node.id)
    
    net.row_objects('hw_node').each do |other|
      next if processed.include?(other.id)
      dist = Math.sqrt((node.x - other.x)**2 + (node.y - other.y)**2)
      if dist <= threshold
        cluster << other
        processed.add(other.id)
      end
    end
    clusters << cluster if cluster.length > 1
  end
  clusters
end
```

### PAT_NEAREST_OBJECT_026: Find Nearest Node
**Intent:** Spatial proximity without index  
**Failure Modes:** O(n) complexity - inefficient for large networks  

```ruby
def nearest_node(net, x, y)
  min_dist = Float::INFINITY
  nearest = nil
  net.row_objects('hw_node').each do |n|
    next unless n.x && n.y
    dist = Math.sqrt((n.x - x)**2 + (n.y - y)**2)
    if dist < min_dist
      min_dist = dist
      nearest = n
    end
  end
  nearest
end
```

---

## 10. Utility Patterns

### PAT_GUID_GEN_031: GUID Generation
**Intent:** Unique identifiers for tracking  
**Failure Modes:** Windows only; falls back to SecureRandom  

```ruby
begin
  require 'Win32API'
  uuid_create = Win32API.new('rpcrt4', 'UuidCreate', 'P', 'L')
  def new_guid
    result = ' ' * 16
    uuid_create.call(result)
    result.unpack('SSSSSSSS').then { |a| sprintf('%04X%04X-%04X-%04X-%04X-%04X%04X%04X', *a) }
  end
rescue LoadError
  def new_guid; require 'securerandom'; SecureRandom.uuid; end
end
```

### PAT_DYNAMIC_FIELD_ACCESS_032: Bracket Field Access
**Intent:** Iterate numbered field sequences  

```ruby
(1..10).each do |i|
  val = land_use["runoff_index_#{i}"]
  puts "Runoff surface #{i}: #{val}" if val
end
```

### PAT_HASH_TRACKING_033: Fast Object Lookup
**Intent:** O(1) membership tests  

```ruby
selected = {}
net.row_objects_selection('hw_runoff_surface').each { |o| selected[o.id.to_s] = true }
if selected.key?(some_id.to_s)
  # process
end
```

### PAT_BATCH_PROCESS_034: Batch with Progress
**Intent:** Reduce memory, provide feedback  

```ruby
def batch_process(objects, batch_size: 200)
  total = objects.length
  done = 0
  objects.each_slice(batch_size) do |batch|
    batch.each { |obj| yield(obj) if block_given? }
    done += batch.length
    puts "Progress: #{done}/#{total} (#{(done.to_f/total*100).round(1)}%)"
  end
end
```

### PAT_TIMESTAMP_035: Timestamp Tokens
**Intent:** Temporal markers for audit trails  

```ruby
timestamp_iso = Time.now.utc.strftime('%Y-%m-%dT%H:%M:%SZ')
friendly_stamp = Time.now.strftime('%Y%m%d_%H%M%S')
object.user_text_1 = "Updated_#{friendly_stamp}"
```

### PAT_CONDITIONAL_FILTER_036: Early-Out Skip Logic
**Intent:** Efficient filtering in loops  

```ruby
net.row_objects('hw_node').each do |n|
  next if n.ground_level.nil? || n.system_type.to_s.downcase != 'storm'
  # process storm node
end
```

### PAT_STRUCTURE_TO_ARRAY_024: Export WSStructure
**Intent:** Convert structure to serializable format  

```ruby
def structure_to_array(structure)
  return [] unless structure.is_a?(WSStructure)
  (0...structure.length).map do |i|
    Hash[structure[i].table_info.fields.map { |f| [f.name, structure[i][f.name]] }]
  end
end
```

### PAT_PROGRESS_LOG_037: Progress Logger
**Intent:** Feedback for long operations  

```ruby
def progress_log(current, total, step=100)
  return unless (current % step).zero?
  pct = (current.to_f/total*100).round(1)
  puts "Processed #{current}/#{total} (#{pct}%)"
end
```

### PAT_FAST_LOOKUP_SET_038: Set for Membership
**Intent:** O(1) vs O(n) lookups  

```ruby
require 'set'
id_set = Set.new(net.row_objects('hw_node').map(&:id))
```

### PAT_ITERATION_CAP_039: Safety Cap
**Intent:** Prevent infinite loops  

```ruby
max_iter = 10_000
iter = 0
while queue.any? && iter < max_iter
  # work
  iter += 1
end
```

### PAT_PROGRESS_LOG_037: Progress Logger
**Intent:** Feedback for long operations  

```ruby
def progress_log(current, total, step=100)
  return unless (current % step).zero?
  pct = (current.to_f/total*100).round(1)
  puts "Processed #{current}/#{total} (#{pct}%)"
end
```

### PAT_COLLECTION_BUILD_040: Dual Collection
**Intent:** Build all and selected arrays  

```ruby
all_ids = []
selected = []
net.row_objects('hw_node').each do |n|
  all_ids << n.node_id
  selected << n if n.selected?
end
```

### PAT_COMMIT_MESSAGE_STD_041: Standardized Commit
**Intent:** Descriptive audit trail  

```ruby
net.commit("Update: user_text_1 bulk modification (#{modified} objects)")
```

### PAT_ENV_CONFIG_042: Environment-Driven Config
**Intent:** Externalize configuration  

```ruby
db_path = ENV.fetch('ICM_DB_PATH', 'database.icmm')
network_id = ENV.fetch('ICM_NETWORK_ID', '1')
```

---

## Common Object Tables

**NOTE:** For complete database table name listings (including SWMM tables and all object types), see `InfoWorks_ICM_Ruby_Database_Reference.md`.

**Commonly Used InfoWorks Tables:**

| Table Name | Object Type | Common ID Field |
|------------|-------------|-----------------|
| `hw_node` | Nodes/Manholes | `node_id` |
| `hw_conduit` | Pipes/Conduits | `us_node_id`, `ds_node_id` |
| `hw_subcatchment` | Subcatchments | `subcatchment_id` |
| `hw_river_reach` | River Reaches | `us_node_id` |
| `hw_1d_results_point` | 1D Results | varies |
| `hw_2d_point` | 2D Mesh Points | varies |
| `hw_runoff_surface` | Runoff Surfaces | `runoff_surface_id` |
| `hw_land_use` | Land Uses | `land_use_id` |
| `hw_ground_infiltration` | Infiltration | varies |
| `hw_rtc` | RTC Objects | `rtc_id` |

---

## See Also

- **Database Reference**: `InfoWorks_ICM_Ruby_Database_Reference.md` - Complete table name lookup for InfoWorks and SWMM
- **Tutorial Context**: `InfoWorks_ICM_Ruby_Tutorial_Context.md` - Learning guide with complete examples

---

## Quick Tips for LLM Code Generation

1. **Always use transactions** for data modifications (PAT_TRANSACTION_010)
2. **Check for nil** before accessing properties (PAT_NULL_GUARD_028)
3. **Mark objects _seen** during tracing to prevent loops (PAT_TRACE_RESET_016)
4. **Call write()** after modifying properties
5. **Clear selections** before building new ones (PAT_SELECTION_CLEAR_008)
6. **Use Set or Hash** for fast membership tests (PAT_FAST_LOOKUP_SET_038)
7. **Provide progress feedback** for long operations (PAT_PROGRESS_LOG_037)
8. **Handle errors gracefully** with rescue blocks (PAT_ERROR_WRAP_027)
9. **Validate field existence** for cross-version scripts (PAT_FIELD_EXISTS_030)
10. **Use descriptive commit messages** (PAT_COMMIT_MESSAGE_STD_041)
